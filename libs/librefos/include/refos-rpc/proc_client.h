/* DO NOT EDIT MANUALLY!!!
   This file was generated by CIDL.

   Copyright 2016, Data61
   Commonwealth Scientific and Industrial Research Organisation (CSIRO)
   ABN 41 687 119 230.

   This software may be distributed and modified according to the terms of
   the BSD 2-Clause license. Note that NO WARRANTY is provided.
   See "LICENSE_BSD2.txt" for details.

   @TAG(D61_BSD)
*/

#ifndef _RPC_INTERFACE_PROC_CLIENT_H_
#define _RPC_INTERFACE_PROC_CLIENT_H_

#include <refos-rpc/rpc.h>
#include <refos/refos.h>


/*! @file
    @brief Generated file for the proc interface. Please do NOT edit this file. */

#ifndef _RPC_PROC_LABEL_ENUMS_
#define _RPC_PROC_LABEL_ENUMS_
/*! @brief RPC syscall label enums for proc interface. */
enum rpc_proc_label_enum {
    RPC_PROC_LABEL_MIN = PROCSERV_METHODS_BASE,
    RPC_PROC_PING,
    RPC_PROC_NEW_ENDPOINT_INTERNAL,
    RPC_PROC_NEW_ASYNC_ENDPOINT_INTERNAL,
    RPC_PROC_WATCH_CLIENT,
    RPC_PROC_UNWATCH_CLIENT,
    RPC_PROC_CREATE_MEM_WINDOW_INTERNAL,
    RPC_PROC_RESIZE_MEM_WINDOW,
    RPC_PROC_DELETE_MEM_WINDOW,
    RPC_PROC_GET_MEM_WINDOW,
    RPC_PROC_GET_MEM_WINDOW_DSPACE,
    RPC_PROC_REGISTER_AS_PAGER,
    RPC_PROC_UNREGISTER_AS_PAGER,
    RPC_PROC_NOTIFICATION_BUFFER,
    RPC_PROC_WINDOW_MAP,
    RPC_PROC_WINDOW_UNMAP,
    RPC_PROC_WINDOW_GETID,
    RPC_PROC_SET_PARAMBUFFER,
    RPC_PROC_NEW_PROC,
    RPC_PROC_EXIT,
    RPC_PROC_CLONE_INTERNAL,
    RPC_PROC_NICE,
    RPC_PROC_GET_IRQ_HANDLER,
    RPC_PROC_LABEL_MAX
};
#endif

/*! @brief Ping the process server. Useful for debugging.
   @return REFOS_ESUCCESS if success, refos_error error code otherwise. */
refos_err_t proc_ping();

/*! @brief Create a new sync endpoint.

   The client's vspace owns the created endpoint, and the EP will be deleted when the client
   exits.

   @param errval Variable to store error code in.
   @return Recieved cap if success, 0 otherwise. */
seL4_CPtr proc_new_endpoint_internal(refos_err_t* errval);

/*! @brief Create a new asynchronous endpoint.

   The client's vspace owns the created endpoint, and the EP will be deleted when the client
   exits.

   @param errval Variable to store error code in.
   @return Recieved cap if success, 0 otherwise. */
seL4_CPtr proc_new_async_endpoint_internal(refos_err_t* errval);

/*! @brief Watch a client and set up to be notified of its death.
   @param liveness The liveliness cap of the client.
   @param deathEP The endpoint through which death notification will happen.
   @param deathID The deathID which will be passed in the notification.
   @return REFOS_ESUCCESS if success, refos_error error code otherwise. */
refos_err_t proc_watch_client(seL4_CPtr liveness, seL4_CPtr deathEP, int32_t* deathID);

/*! @brief Stop watching a client and remove death notifications about it.

   @param liveness The liveliness cap of the client.
   @return REFOS_ESUCCESS if success, refos_error error code otherwise. */
refos_err_t proc_unwatch_client(seL4_CPtr liveness);

/*! @brief Create a new memory window segment.

   Likely to have implementation and/or technical restrictions regarding window base addrs and
   mapped dataspaces. For the details, looking at the documentation for the implementation is
   strongly recommended. On error, 0 is returned and errval is set.

   @param vaddr The window base address in the calling client's VSpace.
   @param size The size of the mem window.
   @param permissions The read / write permission bitmask.
   @param permissions The flags bitmask (cached / uncached).
   @param errval The returned error number, if any errors.
   @return Capability to created window if success, 0 otherwise (errval will be set).
   (Gives ownership) */
seL4_CPtr proc_create_mem_window_internal(uint32_t vaddr, uint32_t size, uint32_t permissions, uint32_t flags, refos_err_t* errval);

/*! @brief Resize a memory window segment.

   @param window Capability of the window to resize. (No ownership)
   @param size The new window size.
   @return REFOS_ESUCCESS if success, refos_error error code otherwise. */
refos_err_t proc_resize_mem_window(seL4_CPtr window, uint32_t size);

/*! @brief Delete a memory window segment.

   @param window Capability of the window to delete. (Takes ownersip)
   @return REFOS_ESUCCESS if success, refos_error error code otherwise. */
refos_err_t proc_delete_mem_window(seL4_CPtr window);

/*! @brief Get the memory window segment in calling client's own vspace at given addr.

   @param vaddr The virtual memory address to get window for.
   @return Capability to window at the given vaddr.  (Gives ownership) */
seL4_CPtr proc_get_mem_window(uint32_t vaddr);

/*! @brief Get the anonymous dataspace mapped at the given window.

   Get the anonymous dataspace mapped at the given window. This function is very useful to
   avoid some complex double-book-keeping scenarios.

   @param window The window to get mapped dataspace for. (No ownership)
   @param errval The returned error number, if any errors.
   @return 0 if error or no dataspace mapped, capability to the mapped dataspace at the given
   window otherwise. (Gives ownership) */
seL4_CPtr proc_get_mem_window_dspace(seL4_CPtr window, refos_err_t* errval);

/*! @brief Register to be the pager for a client process's memory window.

   @param window the memory window to page for.
   @param faultNotifyEP The async endpoint which the fault notifications will be sent through.
   @param winID The ID of the window, which will be used to identify which window faulted. The
   server most likely will have to book-keep this ID to handle faults correctly.
   @return REFOS_ESUCCESS if success, refos_error error code otherwise. */
refos_err_t proc_register_as_pager(seL4_CPtr window, seL4_CPtr faultNotifyEP, seL4_Word* winID);

/*! @brief Unregister to stop being the pager for a client process's memory window.
   @param window the memory window stop paging for. */
refos_err_t proc_unregister_as_pager(seL4_CPtr window);

/*! @brief Use the given RAM dataspace as the notification buffer.

   The specific implementation of the process server may or may not support notification
   buffers backed by internal and/or external dataspaces. Referring to the documentation for
   the process server implementation is strongly recommended in order to find out what kind(s)
   of dataspaces are supported.

   @param dataspace The dataspace to use as the notification buffer.
   @return REFOS_ESUCCESS if success, refos_error error code otherwise. */
refos_err_t proc_notification_buffer(seL4_CPtr dataspace);

/*! @brief Map a frame in the dataserver's own VSpace into the faulted window.

   This syscall is most commonly used in response to a prior fault notification from the
   process server. Maps the frame at the given VSpace into the client's faulted window, and
   then resolves the fault and resumes execution of the faulting client. Also may be used to
   eagerly map frames into clients before they VMfault there.

   @param window Cap to the window to map the frame into.
   @param windowOffset The offset into the window to map the frame into.
   @param srcAddr The address of the source frame in the calling process's own VSpace;
   this address should contain a valid frame, and should be page-aligned.
   @return REFOS_ESUCCESS if success, refos_error error code otherwise. */
refos_err_t proc_window_map(seL4_CPtr window, uint32_t windowOffset, uint32_t srcAddr);

refos_err_t proc_window_unmap();

/*! @brief Get the window ID associated with window capability.
   @param window The window capability to retrieve window ID for.
   @return -refos_err_t error on error, windowID value otherwise. */
int proc_window_getID(seL4_CPtr window);

/*! @brief Use the given dataspace as the parameter buffer for process server syscalls.

   Whether internal and/or external dataspaces are supported for use as the parameter buffer is
   implementation-specific. Referring to the documentation for the process server
   implementation is strongly recommended in order to find out which type(s) of dataspaces are
   supported.

   @param dataspace The dataspace to use as the parameter buffer for subsequent procserv
   syscalls.
   @param size The size of the param buffer.
   @return REFOS_ESUCCESS if success, refos_error error code otherwise. */
refos_err_t proc_set_parambuffer(seL4_CPtr dataspace, uint32_t size);

/*! @brief Runs a new process.

   Starts a new process, blocking or non-blocking.

   @param name The executable file name of the process to start.
   @param params The parameters to pass onto the new process.
   @param block Whether to block until the process exits. (1/0) (non-blocking unimplemented)
   @param priority The priority (0-255) of the new process.
   @param status The exit status of the process. (output, only used if blocking is set)
   @return REFOS_ESUCCESS if success, refos_error error code otherwise. */
refos_err_t proc_new_proc(char* name, char* params, bool block, int32_t priority, int32_t* status);

/*! @brief Exits and deletes the calling process.
   @param status The exit status of the process.
   @return doesn't return. */
refos_err_t proc_exit(int32_t status);

/*! @brief Clones a new thread for process.

   Starts a new thread, sharing the current process' vspace. Each thread must have its own
   entry point, stack and IPC buffer (the IPC buffer will be dynamically allocated). The child
   thread will have the same priority as the parent process.

   @param entryPoint The entry point vaddr of the new thread.
   @param childStack The stack vaddr of the new thread.
   @param flags Unused, must be 0.
   @param arg Unused, must be 0.
   @param errval The resulting refos_error error code, if an error occured.
   @return threadID if success, negative if error occured. */
int proc_clone_internal(seL4_Word entryPoint, seL4_Word childStack, int flags, seL4_Word arg, refos_err_t* errval);

/*! @brief Set the given thread's priority.

   @param threadID The thread ID to set priority for.
   @param priority The priority to set to.
   @return REFOS_ESUCCESS if success, refos_error error code otherwise. */
refos_err_t proc_nice(int threadID, int priority);

/*! @brief Get the IRQ handler endpoint for the given IRQ number. Requires IRQ handler
   permission.
   @param irq The IRQ number to get handler for
   @return IRQ handler endpoint on success, 0 otherwise. */
seL4_CPtr proc_get_irq_handler(int irq);

#endif /* _RPC_INTERFACE_PROC_CLIENT_H_ */

