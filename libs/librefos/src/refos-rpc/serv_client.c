/* DO NOT EDIT MANUALLY!!!
   This file was generated by CIDL.

   Copyright 2016, Data61
   Commonwealth Scientific and Industrial Research Organisation (CSIRO)
   ABN 41 687 119 230.

   This software may be distributed and modified according to the terms of
   the BSD 2-Clause license. Note that NO WARRANTY is provided.
   See "LICENSE_BSD2.txt" for details.

   @TAG(D61_BSD)
*/

#include <refos-rpc/rpc.h>
#include <refos-rpc/serv_client.h>
#include <refos/refos.h>

#include <refos/vmlayout.h>

#include <stdint.h>
#include <stdlib.h>

/*! @file
    @brief Generated file for the serv interface. Please do NOT edit this file. */

seL4_CPtr serv_connect_direct(seL4_CPtr serv, seL4_CPtr liveness, int* errval) {
    int rpc__error_;
    seL4_CPtr __ret__;
    memset(&__ret__, 0, sizeof(seL4_CPtr));

    rpc_init("serv_connect_direct", RPC_SERV_CONNECT_DIRECT);
    rpc_set_dest(serv);
    rpc_push_cptr(liveness);

    rpc__error_ = rpc_call_server();
    if (rpc__error_) {
        rpc_release();
        return __ret__;
    }

    rpc_pop_buf(errval, sizeof(int));
    __ret__ = (seL4_CPtr) rpc_pop_cptr();
    __ret__ = rpc_copyout_cptr(__ret__);
    rpc_release();
    return __ret__;
}

refos_err_t serv_ping(seL4_CPtr session) {
    int rpc__error_;
    refos_err_t __ret__;
    memset(&__ret__, 0, sizeof(refos_err_t));

    rpc_init("serv_ping", RPC_SERV_PING);
    rpc_set_dest(session);

    rpc__error_ = rpc_call_server();
    if (rpc__error_) {
        rpc_release();
        return __ret__;
    }

    rpc_pop_buf(&__ret__, sizeof(refos_err_t));
    rpc_release();
    return __ret__;
}

refos_err_t serv_set_param_buffer(seL4_CPtr session, seL4_CPtr parambuffer_dataspace, uint32_t parambuffer_size) {
    int rpc__error_;
    refos_err_t __ret__;
    memset(&__ret__, 0, sizeof(refos_err_t));

    rpc_init("serv_set_param_buffer", RPC_SERV_SET_PARAM_BUFFER);
    rpc_set_dest(session);
    rpc_push_cptr(parambuffer_dataspace);
    rpc_push_uint(parambuffer_size);

    rpc__error_ = rpc_call_server();
    if (rpc__error_) {
        rpc_release();
        return __ret__;
    }

    rpc_pop_buf(&__ret__, sizeof(refos_err_t));
    rpc_release();
    return __ret__;
}

void serv_disconnect_direct(seL4_CPtr session) {
    int rpc__error_;

    rpc_init("serv_disconnect_direct", RPC_SERV_DISCONNECT_DIRECT);
    rpc_set_dest(session);

    rpc__error_ = rpc_call_server();
    if (rpc__error_) {
        rpc_release();
    }

    rpc_release();
}


